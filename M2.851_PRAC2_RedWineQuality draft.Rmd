---
title: 'Tipologia y ciclo de vida de los datos - PRA2'
author: "Autor: Eduardo Diaz Villanueva e Ignasi Domingo González"
date: "Enero 2021"
output:
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Descripción del dataset.

```{r }
library(stringr)
library(dplyr)
library(ggplot2)
library(corrplot)


# Limpiamos la aplicacion de datos anteriores y cargo el fichero.
rm(list = ls())
datos <- read.csv("winequality-red.csv", sep=",")
datos_originales <- datos

#shape(datos)
#describe(datos)

head(datos,5)
```

El dataset seleccionado contiene 11 variables que describen las propiedades quimicas de un vino, como puede ser la acided, ph nivel de azucar, etc... estas variables tendran influencia en la calidad final del vino.

Con este ejercicio queremos estudiar que variables son mas representativas y encontrar modelos que puedan predecir la calidad del vino.

Si pensamos por ejemplo en una industria, podriamos reducir el tiempo y coste reduciendo el numero de pruebas de calidad a las variables mas significativas. Incluso mejorar la calidad del producto final, focalizando esfuerzos y recursos a reducir la variabiliad de las varibles que mas contribuyan a la calidad final.

# Integracion y seleccion de los datos de interes

Realizaremos un primer analisis estadistico para familiarizarnos con las variables y sus tipos de datos.
````{r }
summary(datos)
str(datos)

#Tipo de dato asignado a cada campo
sapply(datos, function(x) class(x))
```

Observamos que los tipos de datos asignados a las variables corresponden con las variables que representan.

# Limpieza de los datos

## Elementos vacios

Analizamos los valores de las variables para detectar falta o ausencia de datos
````{r }
# Analizamos la existencia de datos NA
colSums(is.na(datos))
```

````{r }
# Analizamos la existencia de datos vacios
colSums(datos=="")
```

````{r }
# Analizamos la existencia de datos con valor 0
colSums(datos==0)

```

Observamos la variable Citric.acid con una gran cantidad de valores 0. 

## Valores extremos 

Analizaremos individualmente cada una de las variables focalizandonos en la distribucion de los datos y sus valores extremos.

````{r }

par(mfrow=c(1,2))
hist(datos$fixed.acidity)
boxplot(datos$fixed.acidity,main="fixed.acidity", col="gray")
boxplot.stats(datos$fixed.acidity)$out

par(mfrow=c(1,2))
hist(datos$volatile.acidity)
boxplot(datos$volatile.acidity,main="volatile.acidity", col="gray")
boxplot.stats(datos$volatile.acidity)$out

par(mfrow=c(1,2))
hist(datos$citric.acid )
boxplot(datos$citric.acid ,main="citric.acid ", col="gray")
boxplot.stats(datos$citric.acid )$out

par(mfrow=c(1,2))
hist(datos$residual.sugar)
boxplot(datos$residual.sugar,main="residual.sugar", col="gray")
boxplot.stats(datos$residual.sugar)$out

par(mfrow=c(1,2))
hist(datos$chlorides)
boxplot(datos$chlorides,main="chlorides", col="gray")
boxplot.stats(datos$chlorides)$out

par(mfrow=c(1,2))
hist(datos$free.sulfur.dioxide)
boxplot(datos$free.sulfur.dioxide,main="free.sulfur.dioxide", col="gray")
boxplot.stats(datos$free.sulfur.dioxide)$out

par(mfrow=c(1,2))
hist(datos$total.sulfur.dioxide)
boxplot(datos$total.sulfur.dioxide,main="total.sulfur.dioxide", col="gray")
boxplot.stats(datos$total.sulfur.dioxide)$out

par(mfrow=c(1,2))
hist(datos$density)
boxplot(datos$density,main="density", col="gray")
boxplot.stats(datos$density)$out

par(mfrow=c(1,2))
hist(datos$pH)
boxplot(datos$pH,main="pH", col="gray")
boxplot.stats(datos$pH)$out

par(mfrow=c(1,2))
hist(datos$sulphates)
boxplot(datos$sulphates,main="sulphates", col="gray")
boxplot.stats(datos$sulphates)$out

par(mfrow=c(1,2))
hist(datos$alcohol)
boxplot(datos$alcohol,main="alcohol", col="gray")
boxplot.stats(datos$alcohol)$out

par(mfrow=c(1,2))
hist(datos$quality)
boxplot(datos$quality,main="quality", col="gray")
boxplot.stats(datos$quality)$out

```


# Analisis

Antes de comenzar con el analisis guardaremos una copia de los datos despues del proceso de limpieza
````{r }
# Exportación de los datos limpios en .csv
write.csv(datos, "RedWinQuality_clean.csv")

```

Analizaremos las variables frente a la calidad para decidir cuaes utilizar en el resto del analisis

````{r }
#boxplot(datos$pH,main="quality", col="gray")
boxplot(formula = datos$fixed.acidity ~ datos$quality, main="fixed.acidity vs quality", col="gray")

boxplot(formula = datos$volatile.acidity ~ datos$quality, main="volatile.acidity vs quality", col="gray")

boxplot(formula = datos$citric.acid ~ datos$quality, main="citric.acid vs quality", col="gray")

boxplot(formula = datos$residual.sugar ~ datos$quality, main="residual.sugar vs quality", col="gray")

boxplot(formula = datos$chlorides ~ datos$quality, main="chlorides vs quality", col="gray")

boxplot(formula = datos$free.sulfur.dioxide ~ datos$quality, main="free.sulfur.dioxide vs quality", col="gray")

boxplot(formula = datos$total.sulfur.dioxide ~ datos$quality, main="total.sulfur.dioxide vs quality", col="gray")

boxplot(formula = datos$density ~ datos$quality, main="density vs quality", col="gray")

boxplot(formula = datos$pH ~ datos$quality, main="pH vs quality", col="gray")

boxplot(formula = datos$sulphates ~ datos$quality, main="sulphates vs quality", col="gray")

boxplot(formula = datos$alcohol ~ datos$quality, main="alcohol vs quality", col="gray")

```



## Seleccion grupo de datos

De la observacion del grupo de datos nos interesa seleccionar los que pudieran tener una mayor relacion con el resultado de calidad. Por ello vamos a seleccionar las que se intuye una cierta relacion lineal para poder apolicar modelos de prediccion.

las variables fixed acidity, citrix acid , alcohol y sulfates conforme aunmentan, aumenta el valor de la calidad. 
Por el contrario para que aumente el valor de la calidad es necesario que disminuyan volatile acidity, density y pH.

Crearemos un subconjunto de datos con estas cinco variables
````{r }
subdatos <- select(datos, fixed.acidity, volatile.acidity, citric.acid, sulphates, alcohol)

```


## Comprobación de la normalidad y homogeneidad de la varianza.

Comprobaremos la normalidad de los datos y ejecutaremos el test.

````{r }

par(mfrow=c(3,4))
for (i in 1:(ncol(datos)-1)) {
  qqnorm(datos[,i], main = colnames(datos[i]))
  qqline(datos[,i])
}

```

Dado que los grupos tienen mas de 50 eventos se emplea el test de Kolmogorov-Smirnov con la corrección de Lilliefors. La función en R se llama lillie.test() y se encuentra en el paquete nortest. Si fuesen menos de 50 eventos por grupo se emplearía el test Shapiro-Wilk.

```{r ,eval=TRUE,echo=TRUE}
# Test de Shapiro
#shapiro.test(datos$fixed.acidity)


# Test de Kolmogorov

library("nortest")
kol <- lillie.test(x = datos$quality)


# Creamos la matriz para almacenar los datos
matrixkol <- matrix(nc = 3, nr = 0)
colnames(matrixkol) <- c("Variable","TestKol","p-value")

# Recorremos el dataset ejecutando el test
for (i in 1:(ncol(datos)-1)) {
  
  kol <- lillie.test(x = datos[,i])
  # Añadimos los datos a la matriz
  pair = matrix(ncol = 3, nrow = 1)
  pair[1][1] = colnames(datos[i])
  pair[2][1] = kol[1]
  pair[3][1] = kol[2]
  matrixkol <- rbind(matrixkol, pair)
}

# Ordenamos por el valor de correlacion
#matrixkol[order(matrixkol[,"correlacion"]), ]
matrixkol

```

Una vez comprobada la normalidad de los datos, realizaremos un analisis de la varianza.

```{r ,eval=TRUE,echo=TRUE}
#anova <- aov(datos$bateo ~ datos$posicion)
#summary(anova)
##                 Df Sum Sq  Mean Sq F value Pr(>F)
## datos$posicion   3 0.0076 0.002519   1.994  0.115
## Residuals      323 0.4080 0.001263
#plot(anova)

```




````{r }

```

## Aplicación de pruebas estadísticas para comparar los grupos de datos


Analicemos ahora los valores de correlacion de las varables con la varible quality y la ordenamos 

````{r }
# Visualizaremos la matriz de correlacion de variables
correlacion<-round(cor(datos), 1)
corrplot(correlacion, method="number", type="upper")

```

Guardaremos los datos de correlacion en una matriz ordenada para decir que variables utilizar en siguientes estudios

````{r }
# Creamos la matriz para almacenar los datos
matrixcor <- matrix(nc = 2, nr = 0)
colnames(matrixcor) <- c("Variable","correlacion")

# Recorremos el dataset ejecutando el test
for (i in 1:(ncol(datos)-1)) {
  
  coef <- cor(x=datos$quality, y = datos[,i], method="spearman")
  # Añadimos los datos a la matriz
  pair = matrix(ncol = 2, nrow = 1)
  pair[1][1] = colnames(datos[i])
  pair[2][1] = coef
  matrixcor <- rbind(matrixcor, pair)
}

# Ordenamos por el valor de correlacion
matrixcor[order(matrixcor[,"correlacion"]), ]
```

Con este grupo de datos y las relaciones observadas tanto en las graficas de caja como los datos de correlacion estimaremos por mínimos cuadrados ordinarios un modelo lineal que explique la variable quality

````{r }
# Estimar 
modelo <- (lm(formula = quality ~ fixed.acidity + citric.acid + alcohol + sulphates + volatile.acidity + density + pH, data = datos))
summary(modelo)

```


````{r }

# La interpretacion del modelo seria
 
#y <- 23.89874 + (0.06451 * fixed.acidity) - (0.48194 * citric.acid) + (0.30768 * alcohol) + (0.71648 * sulphates) - (1.30791  * volatile.acidity) - (21.23262 * density) - (0.14902 * pH)

```


```


# Representación de los resultados

````{r }

```

# Resolución del problema

````{r }

```
