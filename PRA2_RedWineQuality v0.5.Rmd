---
title: 'Tipologia y ciclo de vida de los datos - PRA2'
author: "Autor: Eduardo Diaz Villanueva e Ignasi Domingo González"
date: "Enero 2021"
output:
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Descripción del dataset.

```{r }
library(stringr)
library(dplyr)
library(ggplot2)
library(corrplot)
# Limpiamos la aplicacion de datos anteriores y cargo el fichero.
rm(list = ls())
datos <- read.csv("winequality-red.csv", sep=",")
datos_originales <- datos
#shape(datos)
#describe(datos)
head(datos,5)
```

El dataset seleccionado contiene 11 variables que describen las propiedades químicas de un vino, como puede ser la acidez, ph nivel de azúcar, etc... estas variables tendrán influencia en la calidad final del vino.

Con este ejercicio queremos estudiar que variables son mas representativas y encontrar modelos que puedan predecir la calidad del vino.

Si pensamos por ejemplo en una industria, podríamos reducir el tiempo y coste reduciendo el numero de pruebas de calidad a las variables mas significativas. Incluso mejorar la calidad del producto final, focalizando esfuerzos y recursos a reducir la variabilidad de las variables que mas contribuyan a la calidad final.

# Integracion y seleccion de los datos de interes

Realizaremos un primer análisis estadístico para familiarizarnos con las variables y sus tipos de datos.
````{r }
summary(datos)
str(datos)
#Tipo de dato asignado a cada campo
sapply(datos, function(x) class(x))
```
Observamos que los tipos de datos asignados a las variables corresponden con las variables que representan.
# Limpieza de los datos

## Elementos vacios
Analizamos los valores de las variables para detectar falta o ausencia de datos
````{r }
# Analizamos la existencia de datos NA
colSums(is.na(datos))
```
````{r }
# Analizamos la existencia de datos vacios
colSums(datos=="")
```
````{r }
# Analizamos la existencia de datos con valor 0
colSums(datos==0)
```
Observamos la variable "Citric.acid" con una gran cantidad de valores 0.
En la uva, el ácido cítrico es un componente que presente pero menor, con muy baja presencia, lo que si no se añade posteriormente puede presentar valores de 0.
Consideramos que dicha variable tiene valores correctos.


## Elementos duplicados
Dado que no hay presentes registros con elementos vacios, vamos a verificar si hay registros duplicados.

````{r }
# Analizamos la existencia de registros duplicados.
sum(duplicated(datos))
```
Algunas filas están duplicadas. A modo de ejemplo, la fila 1 y la fila 5 son la misma.
````{r }
# Ejemplo de registro duplicado
a <- datos %>% filter(row_number() == 1) 
b <- datos %>% filter(row_number() == 5)
a == b

```


Eliminamos las filas duplicadas
````{r }
# Eliminamos los registros duplicados
datos <- datos[!duplicated(datos), ]

```


````{r }
# Revisamos el tamaño de nuestro nuevo dataset
dim(datos)
```



## Valores extremos 
Analizaremos individualmente cada una de las variables focalizándonos en la distribución de los datos y sus valores extremos.

````{r }
par(mfrow=c(1,2))
hist(datos$fixed.acidity)
boxplot(datos$fixed.acidity,main="fixed.acidity", col="gray")
boxplot.stats(datos$fixed.acidity)$out
```
Observamos como el atributo "fixed.acidity" tiene 41 valores extremos, distribuidos entre 12.4 y 16

````{r }
par(mfrow=c(1,2))
hist(datos$volatile.acidity)
boxplot(datos$volatile.acidity,main="volatile.acidity", col="gray")
boxplot.stats(datos$volatile.acidity)$out
```
Observamos como el atributo "volatile.acidity" tiene 19 valores extremos, distribuidos entre 1 y 1.6


````{r }
par(mfrow=c(1,2))
hist(datos$citric.acid )
boxplot(datos$citric.acid ,main="citric.acid ", col="gray")
boxplot.stats(datos$citric.acid )$out
```
Observamos como el atributo "citric.acid" tiene un valor extremo de valor 1.


````{r }
par(mfrow=c(1,2))
hist(datos$residual.sugar)
boxplot(datos$residual.sugar,main="residual.sugar", col="gray")
boxplot.stats(datos$residual.sugar)$out
```
Observamos como el atributo "residual.sugar" tiene 126 valores extremos, distribuidos entre 4 y 16


````{r }
par(mfrow=c(1,2))
hist(datos$chlorides)
boxplot(datos$chlorides,main="chlorides", col="gray")
boxplot.stats(datos$chlorides)$out
```
Observamos como el atributo "chlorides" tiene 87 valores extremos, distribuidos entre 0 y 0.05 por la parte inferior y entre 0.12 y 0.6 por la parte superior.


````{r }
par(mfrow=c(1,2))
hist(datos$free.sulfur.dioxide)
boxplot(datos$free.sulfur.dioxide,main="free.sulfur.dioxide", col="gray")
boxplot.stats(datos$free.sulfur.dioxide)$out
```
Observamos como el atributo "free.sulfur.dioxide" tiene 26 valores extremos, distribuidos entre el 43 y el 60

````{r }
par(mfrow=c(1,2))
hist(datos$total.sulfur.dioxide)
boxplot(datos$total.sulfur.dioxide,main="total.sulfur.dioxide", col="gray")
boxplot.stats(datos$total.sulfur.dioxide)$out
```
Observamos como el atributo "total.sulfur.dioxide" tiene 45 valores extremos, distribuidos entre el 120 y el 300.


````{r }
par(mfrow=c(1,2))
hist(datos$density)
boxplot(datos$density,main="density", col="gray")
boxplot.stats(datos$density)$out
```
Observamos como el atributo "density" tiene 35 valores extremos, distribuidos entre 0.990 y 0.992 por la parte inferior y entre 1.001 y 1.004 por la parte superior.

````{r }
par(mfrow=c(1,2))
hist(datos$pH)
boxplot(datos$pH,main="pH", col="gray")
boxplot.stats(datos$pH)$out
```
Observamos como el atributo "pH" tiene 28 valores extremos, distribuidos entre 2.7 y 2.9 por la parte inferior y entre 3.7 y 4 por la parte superior.


````{r }
par(mfrow=c(1,2))
hist(datos$sulphates)
boxplot(datos$sulphates,main="sulphates", col="gray")
boxplot.stats(datos$sulphates)$out
```
Observamos como el atributo "sulphates" tiene 55 valores extremos, distribuidos entre 1 y 2.


````{r }
par(mfrow=c(1,2))
hist(datos$alcohol)
boxplot(datos$alcohol,main="alcohol", col="gray")
boxplot.stats(datos$alcohol)$out
```
Observamos como el atributo "alcohol" tiene 12 valores extremos, distribuidos entre el 13.5 y el 14.

````{r }
par(mfrow=c(1,2))
hist(datos$quality)
boxplot(datos$quality,main="quality", col="gray")
boxplot.stats(datos$quality)$out
```
Observamos como el atributo "quality" tiene 27 valores extremos, distribuidos entre el 3 por la parte inferior, y el 8 en la parte superior.
Este valor es una valoración del vino, por lo que estos valores no se pueden considerar extremos.

En conclusión, con el análisis realizado para cada variable, el número de valores extremos es muy dispar, siendo bajo en algunas variables y relativamente alto en otras.

Como la eliminación de todos los valores extremos detectados afectaría sensiblemente a la muestra, vamos a buscar cuales de dichos valores son realmente extremos a partir de la distancia de Cook, estimando el grado de influencia de cada uno de los valores al realizar un análisis de regresión por mínimos cuadrados.

Para realizarlo, tendremos en cuenta todos los atributos a excepción de "quality".


````{r }
# Cálculo y visualización de resultados de aplicar la distancia de Cook a nuestros datos.
outliers = c()
for ( i in 1:11 ) {
  stats = boxplot.stats(datos[[i]])$stats
  bottom_outlier_rows = which(datos[[i]] < stats[1])
  top_outlier_rows = which(datos[[i]] > stats[5])
  outliers = c(outliers , top_outlier_rows[ !top_outlier_rows %in% outliers ] )
  outliers = c(outliers , bottom_outlier_rows[ !bottom_outlier_rows %in% outliers ] )
}

mod = lm(quality ~ ., data = datos)
cooksd = cooks.distance(mod)
plot(cooksd, pch = "*", cex = 2, main = "Observaciones relevantes en función de la distancia de Cook")
abline(h = 4*mean(cooksd, na.rm = T), col = "red")
```
````{r }
# Obtenemos el listado de los valores extremos que afectan sensiblemente a los datos.
head(datos[cooksd > 4 * mean(cooksd, na.rm=T), ])
```

Si visualizamos las primeras entradas, todos ellos tienen valores atípicos en una o más variables. 

El registro 14 tiene los "chlorides" y los "sulphates" muy altos.
El registro 34 tiene el "residual.sugar" muy alto.
El registro 46 tiene el "pH" muy alto.
El registro 80 tiene los "sulphates" altos.
El registro 87 y 93 tienen los "chlorides", los "sulphates" y el "total.sulfur.dioxide" altos.


Vamos a eliminar los valores extremos detectados.

````{r }
# Identificamos los registros a eliminar
coutliers = as.numeric(rownames(datos[cooksd > 4 * mean(cooksd, na.rm=T), ]))

```

````{r }
# Eliminamos los elementos detectados como extremos.
datos = datos[-c(coutliers), ]

# Visualizamos el tamaño y los valores básicos de nuestro nuevo conjunto de datos.
dim(datos)
summary(datos)

```

# Análisis
Antes de comenzar con el análisis guardaremos una copia de los datos después del proceso de limpieza
````{r }
# Exportación de los datos limpios en .csv
#write.csv(datos, "RedWinQuality_clean.csv")
write.csv(datos, "winequality-red-clean.csv")
```

Analizaremos las variables frente a la calidad para decidir cuales utilizar en el resto del analisis
````{r }
#boxplot(datos$pH,main="quality", col="gray")
boxplot(formula = datos$fixed.acidity ~ datos$quality, main="fixed.acidity vs quality", col="gray")
boxplot(formula = datos$volatile.acidity ~ datos$quality, main="volatile.acidity vs quality", col="gray")
boxplot(formula = datos$citric.acid ~ datos$quality, main="citric.acid vs quality", col="gray")
boxplot(formula = datos$residual.sugar ~ datos$quality, main="residual.sugar vs quality", col="gray")
boxplot(formula = datos$chlorides ~ datos$quality, main="chlorides vs quality", col="gray")
boxplot(formula = datos$free.sulfur.dioxide ~ datos$quality, main="free.sulfur.dioxide vs quality", col="gray")
boxplot(formula = datos$total.sulfur.dioxide ~ datos$quality, main="total.sulfur.dioxide vs quality", col="gray")
boxplot(formula = datos$density ~ datos$quality, main="density vs quality", col="gray")
boxplot(formula = datos$pH ~ datos$quality, main="pH vs quality", col="gray")
boxplot(formula = datos$sulphates ~ datos$quality, main="sulphates vs quality", col="gray")
boxplot(formula = datos$alcohol ~ datos$quality, main="alcohol vs quality", col="gray")
```
## Seleccion grupo de datos
De la observación del grupo de datos nos interesa seleccionar los que pudieran tener una mayor relación con el resultado de calidad. Por ello vamos a seleccionar las que se intuye una cierta relación lineal para poder aplicar modelos de predicción.
Las variables "fixed acidity", "citrix acid" , "alcohol" y "sulphates", conforme aumentan, aumenta el valor de la calidad. 
Por el contrario para que aumente el valor de la calidad es necesario que disminuyan "volatile acidity", "density" y "pH".
Crearemos un subconjunto de datos con estas cinco variables
````{r }
subdatos <- select(datos, fixed.acidity, volatile.acidity, citric.acid, sulphates, alcohol)
```

## Comprobación de la normalidad y homogeneidad de la varianza.
Comprobaremos la normalidad de los datos y ejecutaremos el test. Para ello nos ayudaremos de las graficas quantilie-quantile 
````{r }
par(mfrow=c(3,4))
for (i in 1:(ncol(datos)-1)) {
  qqnorm(datos[,i], main = colnames(datos[i]))
  qqline(datos[,i])
}
```
Los resultados graficos nos indican que las variables pueden ser candidatas a la normalizacion si fuera necesario. Aun asi y dado que los grupos tienen menos de 50 eventos emplearemos el test de Shapiro-Wilk para confirmar la hipotesis.

```{r ,eval=TRUE,echo=TRUE}
# Test de Shapiro
#shapiro.test(datos$fixed.acidity)
# Creamos la matriz para almacenar los datos
matrixsha <- matrix(nc = 3, nr = 0)
colnames(matrixsha) <- c("Variable","w","p-value")

# Recorremos el dataset ejecutando el test
for (i in 1:(ncol(datos)-1)) {
  
  sha <- shapiro.test(datos[,i])
  # Añadimos los datos a la matriz
  test = matrix(ncol = 3, nrow = 1)
  test[1][1] = colnames(datos[i])
  test[2][1] = sha[1]
  test[3][1] = sha[2]
  matrixsha <- rbind(matrixsha, test)
}

# Mostramos la tabla
```

Podemos observar de los valores obtenidos que el valor de W en ningun caso es demasiado pequeño con lo que no podemos rechazar la hipotesis nula. Siendo esta que la poblacion de los datos esta distribuida normalmente.
Una vez comprobada la normalidad de los datos, realizaremos un análisis de la varianza.

***
!!! COMPLETAR CON ANOVA?? !!!
***

```{r ,eval=TRUE,echo=TRUE}
#anova <- aov(datos$bateo ~ datos$posicion)
#summary(anova)
##                 Df Sum Sq  Mean Sq F value Pr(>F)
## datos$posicion   3 0.0076 0.002519   1.994  0.115
## Residuals      323 0.4080 0.001263
#plot(anova)
```



## Aplicación de pruebas estadísticas para comparar los grupos de datos

Aplicaremos diversas pruebas estadisticas para analizar la relacion de los datos y poder crear el modelo de prediccion de la calidad.
Comenzaremos por analizar los valores de correlación de las variables con la variable "quality"

### Correlacion
````{r }
# Visualizaremos la matriz de correlacion de variables
correlacion<-round(cor(datos), 1)
corrplot(correlacion, method="number", type="upper")
```
````{r }
# Visualizaremos la matriz de correlacion de las variables seleccionadas anteriormente
correlacion<-round(cor(subdatos), 1)
corrplot(correlacion, method="number", type="upper")
```


Guardaremos los datos de correlación en una matriz ordenada para decir que variables utilizar en siguientes estudios.
````{r }
# Creamos la matriz para almacenar los datos
matrixcor <- matrix(nc = 2, nr = 0)
colnames(matrixcor) <- c("Variable","correlacion")
# Recorremos el dataset ejecutando el test
for (i in 1:(ncol(datos)-1)) {
  
  coef <- cor(x=datos$quality, y = datos[,i], method="spearman")
  # Añadimos los datos a la matriz
  pair = matrix(ncol = 2, nrow = 1)
  pair[1][1] = colnames(datos[i])
  pair[2][1] = coef
  matrixcor <- rbind(matrixcor, pair)
}
# Ordenamos por el valor de correlacion
matrixcor[order(matrixcor[,"correlacion"]), ]
```

### Correlacion lineal
Con este grupo de datos y las relaciones observadas tanto en las gráficas de caja como los datos de correlación estimaremos por mínimos cuadrados ordinarios un modelo lineal que explique la variable "quality".

````{r }
# Creamos el modelo 
modelo <- (lm(formula = quality ~ fixed.acidity + citric.acid + alcohol + sulphates + volatile.acidity + density + pH, data = datos))
summary(modelo)
```
Podemos observar que la densidad y el pH son variales poco significativas para el modelo. Con un valor de R cuadraddo ajustado del 34.47%.


````{r }
# Creamos un modelo reducido 
modelo_reducido <- (lm(formula = quality ~ fixed.acidity + citric.acid + alcohol + sulphates + volatile.acidity, data = datos))
summary(modelo_reducido)
```



Analizamos estadisticamente el modelo.
````{r }
par(mfrow=c(2,2))
plot(modelo_reducido)
```

La gráfica de residuos frente a Fitted muestra si los residuos tienen patrones no lineales. Los residuos alrededor de una línea horizontal sin patrones distintos indican que tenemos relaciones lineales.

La gráfica QQ plot normal muestra los residuos que se ajustan a la línea normal distribuidos.

La grafica Scale-Location muestra si los residuos se distribuyen por igual a lo largo de los rangos de predictores de forma que podemos verificar el supuesto de varianza igual (homocedasticidad). Podemos observar una linea  horizontal con puntos de dispersión iguales.

El gráfico de residuos vs apalancamiento tiene un aspecto típico cuando hay algún caso influyente. Apenas puede ver las líneas de distancia de Cook (una línea punteada roja) porque todos los casos están dentro de la distancia de Cook.


### Correlacion logistica
Con el objetivo de tener un modelo que nos permitiera tener un control de calidad excluyente que nos permitiera decidir si el producto final es bueno o malo. Vamos a crear un modelo de regresion logistica y comparararemos resultados.

````{r }
# Creamo una variale calidad de tipo factor
datos$quality_factor <- as.factor(datos$quality)

# Creamos un variable calidad binomial
datos$category[datos$quality <= 5] <- 0
datos$category[datos$quality > 5] <- 1
datos$category <- as.factor(datos$category)
```


````{r }
# Generamos el modelo
#modelo_log <- glm(quality ~ fixed.acidity + citric.acid + alcohol + sulphates + volatile.acidity, data = datos, family = "binomial")
modelo_log <- glm(category ~ fixed.acidity + citric.acid + alcohol + sulphates + volatile.acidity  + density + pH, data = datos, family = "binomial")
summary(modelo_log)
```
```{r }
confint(object = modelo_log, level = 0.95 )
```

Creamos la tala de confusión correspondiente al modelo.

```{r }
library(vcd)
predicciones <- ifelse(test = modelo_log$fitted.values > 0.5, yes = 1, no = 0)
matriz_confusion <- table(modelo_log$model$category , predicciones, dnn = c("observaciones", "predicciones"))
matriz_confusion
```
Visualizamos los resultados.
```{r }
mosaic(matriz_confusion, shade = T, colorize = T, gp = gpar(fill = matrix(c("green3", "red2", "red2", "green3"), 2, 2)))

```

***
!!! COMPLETAR CON UNA CONCLUSION DEL MODELO !!!
***

````{r }
# La interpretación del modelo seria
 
#y <- 23.89874 + (0.06451 * fixed.acidity) - (0.48194 * citric.acid) + (0.30768 * alcohol) + (0.71648 * sulphates) - (1.30791  * volatile.acidity) - (21.23262 * density) - (0.14902 * pH)
```

***
!!! PARTE DE CLASIFICACION EN PRUEBAS VALORAR INCLUIRLA Y COMO !!!
***

### Modelos de clasificacion

Tambien nos seria util tener algun modelo de clasificacion que pudieramos determinar la calidad del vino en funcion de sus caracteristicas. Podria agrupar los productos o produccion en varios productos de venta, etc...


Crearemos un modelo supervisado.

````{r }
#install.packages("rminer")
library(rminer)

h<-holdout(datos$quality,ratio=2/3,mode="stratified")
data_train<-datos[h$tr,]
data_test<-datos[h$ts,]
print(table(data_train$quality))

```

````{r }
library(caret)
train_control1<- trainControl(method="LOOCV")
train_control2<- trainControl(method="cv", number=10)
train_control3<- trainControl(method="repeatedcv", number=4, repeats=10)
```


````{r }

train_control<- trainControl(method="cv", number=4)
mod<-train(quality~., data=data_train, method="rf", trControl = train_control)
pred <- predict(mod, newdata=data_test)
####confusionMatrix(pred,data_test$quality_factor,positive="7")

```




Crearemos un modelo no supervisado


````{r }

datos.cl<-datos
datos.cl$quality<-NULL
kmeans.res<-kmeans(datos.cl,9)
table(datos$quality,kmeans.res$cluster)

```

````{r }
library(cluster)
kmedoids.res1<-pam(datos.cl,9)
table(datos$quality,kmedoids.res1$cluster)

#library(fpc)
#kmedoids.res2<-pamk(datos.cl)
#table(datos$quality,kmedoids.res2$pamobject$clustering)
```


# Representación de los resultados
````{r }


```
# Resolución del problema
````{r }
```