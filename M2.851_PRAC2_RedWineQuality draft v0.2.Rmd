---
title: 'Tipologia y ciclo de vida de los datos - PRA2'
author: "Autor: Eduardo Diaz Villanueva e Ignasi Domingo González"
date: "Enero 2021"
output:
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Descripción del dataset.

```{r }
library(stringr)
library(dplyr)
library(ggplot2)
library(corrplot)
# Limpiamos la aplicacion de datos anteriores y cargo el fichero.
rm(list = ls())
datos <- read.csv("winequality-red.csv", sep=",")
datos_originales <- datos
#shape(datos)
#describe(datos)
head(datos,5)
```

El dataset seleccionado contiene 11 variables que describen las propiedades químicas de un vino, como puede ser la acidez, ph nivel de azúcar, etc... estas variables tendrán influencia en la calidad final del vino.

Con este ejercicio queremos estudiar que variables son mas representativas y encontrar modelos que puedan predecir la calidad del vino.

Si pensamos por ejemplo en una industria, podríamos reducir el tiempo y coste reduciendo el numero de pruebas de calidad a las variables mas significativas. Incluso mejorar la calidad del producto final, focalizando esfuerzos y recursos a reducir la variabilidad de las variables que mas contribuyan a la calidad final.

# Integracion y seleccion de los datos de interes

Realizaremos un primer análisis estadístico para familiarizarnos con las variables y sus tipos de datos.
````{r }
summary(datos)
str(datos)
#Tipo de dato asignado a cada campo
sapply(datos, function(x) class(x))
```
Observamos que los tipos de datos asignados a las variables corresponden con las variables que representan.
# Limpieza de los datos

## Elementos vacios
Analizamos los valores de las variables para detectar falta o ausencia de datos
````{r }
# Analizamos la existencia de datos NA
colSums(is.na(datos))
```
````{r }
# Analizamos la existencia de datos vacios
colSums(datos=="")
```
````{r }
# Analizamos la existencia de datos con valor 0
colSums(datos==0)
```
Observamos la variable "Citric.acid" con una gran cantidad de valores 0.
En la uva, el ácido cítrico es un componente que presente pero menor, con muy baja presencia, lo que si no se añade posteriormente puede presentar valores de 0.
Consideramos que dicha variable tiene valores correctos.


## Elementos duplicados
Dado que no hay presentes registros con elementos vacios, vamos a verificar si hay registros duplicados.

````{r }
# Analizamos la existencia de registros duplicados.
sum(duplicated(datos))
```
Algunas filas están duplicadas. A modo de ejemplo, la fila 1 y la fila 5 son la misma.
````{r }
# Ejemplo de registro duplicado
a <- datos %>% filter(row_number() == 1) 
b <- datos %>% filter(row_number() == 5)
a == b

```


Eliminamos las filas duplicadas
````{r }
# Eliminamos los registros duplicados
datos <- datos[!duplicated(datos), ]

```


````{r }
# Revisamos el tamaño de nuestro nuevo dataset
dim(datos)
```



## Valores extremos 
Analizaremos individualmente cada una de las variables focalizándonos en la distribución de los datos y sus valores extremos.

````{r }
par(mfrow=c(1,2))
hist(datos$fixed.acidity)
boxplot(datos$fixed.acidity,main="fixed.acidity", col="gray")
boxplot.stats(datos$fixed.acidity)$out
```
Observamos como el atributo "fixed.acidity" tiene 41 valores extremos, distribuidos entre 12.4 y 16

````{r }
par(mfrow=c(1,2))
hist(datos$volatile.acidity)
boxplot(datos$volatile.acidity,main="volatile.acidity", col="gray")
boxplot.stats(datos$volatile.acidity)$out
```
Observamos como el atributo "volatile.acidity" tiene 19 valores extremos, distribuidos entre 1 y 1.6


````{r }
par(mfrow=c(1,2))
hist(datos$citric.acid )
boxplot(datos$citric.acid ,main="citric.acid ", col="gray")
boxplot.stats(datos$citric.acid )$out
```
Observamos como el atributo "citric.acid" tiene un valor extremo de valor 1.


````{r }
par(mfrow=c(1,2))
hist(datos$residual.sugar)
boxplot(datos$residual.sugar,main="residual.sugar", col="gray")
boxplot.stats(datos$residual.sugar)$out
```
Observamos como el atributo "residual.sugar" tiene 126 valores extremos, distribuidos entre 4 y 16


````{r }
par(mfrow=c(1,2))
hist(datos$chlorides)
boxplot(datos$chlorides,main="chlorides", col="gray")
boxplot.stats(datos$chlorides)$out
```
Observamos como el atributo "chlorides" tiene 87 valores extremos, distribuidos entre 0 y 0.05 por la parte inferior y entre 0.12 y 0.6 por la parte superior.


````{r }
par(mfrow=c(1,2))
hist(datos$free.sulfur.dioxide)
boxplot(datos$free.sulfur.dioxide,main="free.sulfur.dioxide", col="gray")
boxplot.stats(datos$free.sulfur.dioxide)$out
```
Observamos como el atributo "free.sulfur.dioxide" tiene 26 valores extremos, distribuidos entre el 43 y el 60

````{r }
par(mfrow=c(1,2))
hist(datos$total.sulfur.dioxide)
boxplot(datos$total.sulfur.dioxide,main="total.sulfur.dioxide", col="gray")
boxplot.stats(datos$total.sulfur.dioxide)$out
```
Observamos como el atributo "total.sulfur.dioxide" tiene 45 valores extremos, distribuidos entre el 120 y el 300.


````{r }
par(mfrow=c(1,2))
hist(datos$density)
boxplot(datos$density,main="density", col="gray")
boxplot.stats(datos$density)$out
```
Observamos como el atributo "density" tiene 35 valores extremos, distribuidos entre 0.990 y 0.992 por la parte inferior y entre 1.001 y 1.004 por la parte superior.

````{r }
par(mfrow=c(1,2))
hist(datos$pH)
boxplot(datos$pH,main="pH", col="gray")
boxplot.stats(datos$pH)$out
```
Observamos como el atributo "pH" tiene 28 valores extremos, distribuidos entre 2.7 y 2.9 por la parte inferior y entre 3.7 y 4 por la parte superior.


````{r }
par(mfrow=c(1,2))
hist(datos$sulphates)
boxplot(datos$sulphates,main="sulphates", col="gray")
boxplot.stats(datos$sulphates)$out
```
Observamos como el atributo "sulphates" tiene 55 valores extremos, distribuidos entre 1 y 2.


````{r }
par(mfrow=c(1,2))
hist(datos$alcohol)
boxplot(datos$alcohol,main="alcohol", col="gray")
boxplot.stats(datos$alcohol)$out
```
Observamos como el atributo "alcohol" tiene 12 valores extremos, distribuidos entre el 13.5 y el 14.

````{r }
par(mfrow=c(1,2))
hist(datos$quality)
boxplot(datos$quality,main="quality", col="gray")
boxplot.stats(datos$quality)$out
```
Observamos como el atributo "quality" tiene 27 valores extremos, distribuidos entre el 3 por la parte inferior, y el 8 en la parte superior.
Este valor es una valoración del vino, por lo que estos valores no se pueden considerar extremos.

En conclusión, con el análisis realizado para cada variable, el número de valores extremos es muy dispar, siendo bajo en algunas variables y relativamente alto en otras.

Como la eliminación de todos los valores extremos detectados afectaría sensiblemente a la muestra, vamos a buscar cuales de dichos valores son realmente extremos a partir de la distancia de Cook, estimando el grado de influencia de cada uno de los valores al realizar un análisis de regresión por mínimos cuadrados.

Para realizarlo, tendremos en cuenta todos los atributos a excepción de "quality".


````{r }
# Cálculo y visualización de resultados de aplicar la distancia de Cook a nuestros datos.
outliers = c()
for ( i in 1:11 ) {
  stats = boxplot.stats(datos[[i]])$stats
  bottom_outlier_rows = which(datos[[i]] < stats[1])
  top_outlier_rows = which(datos[[i]] > stats[5])
  outliers = c(outliers , top_outlier_rows[ !top_outlier_rows %in% outliers ] )
  outliers = c(outliers , bottom_outlier_rows[ !bottom_outlier_rows %in% outliers ] )
}

mod = lm(quality ~ ., data = datos)
cooksd = cooks.distance(mod)
plot(cooksd, pch = "*", cex = 2, main = "Observaciones relevantes en función de la distancia de Cook")
abline(h = 4*mean(cooksd, na.rm = T), col = "red")
```
````{r }
# Obtenemos el listado de los valores extremos que afectan sensiblemente a los datos.
head(datos[cooksd > 4 * mean(cooksd, na.rm=T), ])
```

Si visualizamos las primeras entradas, todos ellos tienen valores atípicos en una o más variables. 

El registro 14 tiene los "chlorides" y los "sulphates" muy altos.
El registro 34 tiene el "residual.sugar" muy alto.
El registro 46 tiene el "pH" muy alto.
El registro 80 tiene los "sulphates" altos.
El registro 87 y 93 tienen los "chlorides", los "sulphates" y el "total.sulfur.dioxide" altos.


Vamos a eliminar los valores extremos detectados.

````{r }
# Identificamos los registros a eliminar
coutliers = as.numeric(rownames(datos[cooksd > 4 * mean(cooksd, na.rm=T), ]))

```

````{r }
# Eliminamos los elementos detectados como extremos.
datos = datos[-c(coutliers), ]

# Visualizamos el tamaño y los valores básicos de nuestro nuevo conjunto de datos.
dim(datos)
summary(datos)

```

# Análisis
Antes de comenzar con el análisis guardaremos una copia de los datos después del proceso de limpieza
````{r }
# Exportación de los datos limpios en .csv
write.csv(datos, "RedWinQuality_clean.csv")
```

Analizaremos las variables frente a la calidad para decidir cuales utilizar en el resto del analisis
````{r }
#boxplot(datos$pH,main="quality", col="gray")
boxplot(formula = datos$fixed.acidity ~ datos$quality, main="fixed.acidity vs quality", col="gray")
boxplot(formula = datos$volatile.acidity ~ datos$quality, main="volatile.acidity vs quality", col="gray")
boxplot(formula = datos$citric.acid ~ datos$quality, main="citric.acid vs quality", col="gray")
boxplot(formula = datos$residual.sugar ~ datos$quality, main="residual.sugar vs quality", col="gray")
boxplot(formula = datos$chlorides ~ datos$quality, main="chlorides vs quality", col="gray")
boxplot(formula = datos$free.sulfur.dioxide ~ datos$quality, main="free.sulfur.dioxide vs quality", col="gray")
boxplot(formula = datos$total.sulfur.dioxide ~ datos$quality, main="total.sulfur.dioxide vs quality", col="gray")
boxplot(formula = datos$density ~ datos$quality, main="density vs quality", col="gray")
boxplot(formula = datos$pH ~ datos$quality, main="pH vs quality", col="gray")
boxplot(formula = datos$sulphates ~ datos$quality, main="sulphates vs quality", col="gray")
boxplot(formula = datos$alcohol ~ datos$quality, main="alcohol vs quality", col="gray")
```
## Seleccion grupo de datos
De la observación del grupo de datos nos interesa seleccionar los que pudieran tener una mayor relación con el resultado de calidad. Por ello vamos a seleccionar las que se intuye una cierta relación lineal para poder aplicar modelos de predicción.
Las variables "fixed acidity", "citrix acid" , "alcohol" y "sulphates", conforme aumentan, aumenta el valor de la calidad. 
Por el contrario para que aumente el valor de la calidad es necesario que disminuyan "volatile acidity", "density" y "pH".
Crearemos un subconjunto de datos con estas cinco variables
````{r }
subdatos <- select(datos, fixed.acidity, volatile.acidity, citric.acid, sulphates, alcohol)
```

## Comprobación de la normalidad y homogeneidad de la varianza.
Comprobaremos la normalidad de los datos y ejecutaremos el test.
````{r }
par(mfrow=c(3,4))
for (i in 1:(ncol(datos)-1)) {
  qqnorm(datos[,i], main = colnames(datos[i]))
  qqline(datos[,i])
}
```
Dado que los grupos tienen mas de 50 eventos se emplea el test de Kolmogorov-Smirnov con la corrección de Lilliefors. La función en R se llama lillie.test() y se encuentra en el paquete nortest. Si fuesen menos de 50 eventos por grupo se emplearía el test Shapiro-Wilk.
```{r ,eval=TRUE,echo=TRUE}
# Test de Shapiro
#shapiro.test(datos$fixed.acidity)
# Test de Kolmogorov
library("nortest")
kol <- lillie.test(x = datos$quality)
# Creamos la matriz para almacenar los datos
matrixkol <- matrix(nc = 3, nr = 0)
colnames(matrixkol) <- c("Variable","TestKol","p-value")
# Recorremos el dataset ejecutando el test
for (i in 1:(ncol(datos)-1)) {
  
  kol <- lillie.test(x = datos[,i])
  # Añadimos los datos a la matriz
  pair = matrix(ncol = 3, nrow = 1)
  pair[1][1] = colnames(datos[i])
  pair[2][1] = kol[1]
  pair[3][1] = kol[2]
  matrixkol <- rbind(matrixkol, pair)
}
# Ordenamos por el valor de correlacion
#matrixkol[order(matrixkol[,"correlacion"]), ]
matrixkol
```
Una vez comprobada la normalidad de los datos, realizaremos un análisis de la varianza.
```{r ,eval=TRUE,echo=TRUE}
#anova <- aov(datos$bateo ~ datos$posicion)
#summary(anova)
##                 Df Sum Sq  Mean Sq F value Pr(>F)
## datos$posicion   3 0.0076 0.002519   1.994  0.115
## Residuals      323 0.4080 0.001263
#plot(anova)
```
````{r }
```
## Aplicación de pruebas estadísticas para comparar los grupos de datos
Analicemos ahora los valores de correlación de las variables con la variable "quality" y la ordenamos 
````{r }
# Visualizaremos la matriz de correlacion de variables
correlacion<-round(cor(datos), 1)
corrplot(correlacion, method="number", type="upper")
```
Guardaremos los datos de correlación en una matriz ordenada para decir que variables utilizar en siguientes estudios.
````{r }
# Creamos la matriz para almacenar los datos
matrixcor <- matrix(nc = 2, nr = 0)
colnames(matrixcor) <- c("Variable","correlacion")
# Recorremos el dataset ejecutando el test
for (i in 1:(ncol(datos)-1)) {
  
  coef <- cor(x=datos$quality, y = datos[,i], method="spearman")
  # Añadimos los datos a la matriz
  pair = matrix(ncol = 2, nrow = 1)
  pair[1][1] = colnames(datos[i])
  pair[2][1] = coef
  matrixcor <- rbind(matrixcor, pair)
}
# Ordenamos por el valor de correlacion
matrixcor[order(matrixcor[,"correlacion"]), ]
```
Con este grupo de datos y las relaciones observadas tanto en las gráficas de caja como los datos de correlación estimaremos por mínimos cuadrados ordinarios un modelo lineal que explique la variable "quality".
````{r }
# Estimar 
modelo <- (lm(formula = quality ~ fixed.acidity + citric.acid + alcohol + sulphates + volatile.acidity + density + pH, data = datos))
summary(modelo)
```
````{r }
# La interpretación del modelo seria
 
#y <- 23.89874 + (0.06451 * fixed.acidity) - (0.48194 * citric.acid) + (0.30768 * alcohol) + (0.71648 * sulphates) - (1.30791  * volatile.acidity) - (21.23262 * density) - (0.14902 * pH)
```
```
# Representación de los resultados
````{r }
```
# Resolución del problema
````{r }
```